{
  "Nav": {
    "title": "Next.js + PrimeReact + i18n",
    "home": "Startseite"
  },
  "Home": {
    "title": "Startseite",
    "intro": "Dies ist eine einfache Landing Page. Verwenden Sie das linke Menü."
  },
  "Sidebar": {
    "home": "Startseite",
    "authorizationCode": "Authorization Code",
    "publicClient": "Public Client",
    "confidentialClient": "Confidential Client",
    "settings": "Einstellungen",
    "language": "Sprache",
    "switchTo": "Wechseln zu {lang}"
  },
  "Settings": {
    "title": "Einstellungen",
    "placeholder": "Platzhalterseite für Einstellungen – Implementierung folgt.",
    "entraTenantIdLabel": "Entra Tenant Id",
    "entraTenantIdHint": "Ihre Entra Tenant Id. Diese wird in der gesamten App verfügbar sein.",
    "save": "Speichern"
  },
  "AuthorizationCode": {
    "publicClientTitle": "Authorization Code (Public Client)",
    "publicClientPlaceholder": "Platzhalterseite für Authorization Code - Public Client – Implementierung folgt.",
    "confidentialClientTitle": "Authorization Code (Confidential Client)",
    "confidentialClientPlaceholder": "Platzhalterseite für Authorization Code - Confidential Client – Implementierung folgt.",
    "PublicClient": {
      "title": "Authorization Code (Public Client)",
      "steps": {
        "overview": "Überblick",
        "settings": "Einstellungen",
        "pkce": "PKCE",
        "authorize": "Autorisieren",
        "callback": "Callback",
        "tokens": "Tokens",
        "decode": "Dekodieren",
        "validate": "Validieren",
        "callApi": "API aufrufen"
      },
      "sections": {
        "settings": {
          "title": "Einstellungen",
          "description": "Konfigurieren Sie Ihre Umgebung für den OAuth-Flow. Geben Sie Ihren Entra-Tenant (GUID) und die Public-Client-ID (GUID) an. Die Redirect-URI wird automatisch aus dem aktuellen Origin ermittelt (schreibgeschützt) und muss in Ihrer App registriert sein. Scopes bestimmen, worum Sie um Zustimmung gebeten werden.",
          "userProvidedTitle": "Vom Benutzer bereitgestellte Einstellungen",
          "userProvidedDescription": "Diese Felder können von Ihnen angepasst werden und werden zum Erstellen der Autorisierungsanfrage verwendet.",
          "localStorageNotice": "Diese Werte werden in Ihrem Browser im lokalen Speicher (localStorage) gespeichert, um die Eingabe zu erleichtern.",
          "resolvedTitle": "Ermittelte (schreibgeschützte) Werte",
          "resolvedDescription": "Diese Werte werden aus dem Tenant und anderen Eingaben abgeleitet. Sie werden nur zur Anzeige dargestellt und können hier nicht geändert werden.",
          "flowPanelTitle": "So funktioniert der Authorization Code + PKCE Flow",
          "flowIntro": "Diese App demonstriert den OAuth 2.0 Authorization Code Flow mit PKCE für Public Clients. Kurz gesagt: URL für die Autorisierung bauen, im Popup anmelden, Code an der Redirect-URI erhalten und dann mithilfe des code_verifier gegen Tokens tauschen.",
          "flowDiagram": "Client (Browser)\n   |\n   | 1) Generate code_verifier + code_challenge (S256)\n   v\nAuthorize Endpoint ------------------------------>\n   |   GET .../authorize?client_id=...&redirect_uri=...\n   |        &response_type=code&scope=...&state=...\n   |        &code_challenge=...&code_challenge_method=S256\n   |\n   | 2) User signs in and consents\n   v\nRedirect (Callback) <------------------------------\n   |   http(s)://your-app/callback/auth-code?code=...&state=...\n   |\n   | 3) Exchange code for tokens with code_verifier\n   v\nToken Endpoint ----------------------------------->\n   |   POST grant_type=authorization_code\n   |        &client_id=...\n   |        &code=...\n   |        &redirect_uri=...\n   |        &code_verifier=...\n   |\n   | 4) Receive tokens (access_token, id_token, ... )\n   v\nProtected API (e.g., Graph) --------------------->\n   |   Authorization: Bearer <access_token>\n   v\n  Response"
        },
        "pkce": {
          "title": "PKCE generieren (code_verifier & code_challenge)",
          "description": "PKCE schützt Public Clients. Klicken Sie auf den Button 'Generieren' (links vom Code Verifier Eingabefeld), um einen hochentropischen code_verifier und die zugehörige code_challenge (standardmäßig S256) zu erstellen."
        },
        "authorize": {
          "title": "Autorisierungs-URL erstellen",
          "description": "Wir erstellen die Autorisierungs-URL inkl. client_id, redirect_uri, Scopes, optionalem state und nonce sowie PKCE-Parametern. Sie können außerdem response_mode, prompt und login_hint setzen, um zu steuern, wie der Identity Provider antwortet oder wie das Anmeldeerlebnis aussieht. Klicken Sie auf ‚Popup öffnen‘, um sich anzumelden und zuzustimmen. Nach der Anmeldung leitet das Popup zurück, und Schritt 5 füllt den Code automatisch aus."
        },
        "callback": {
          "title": "Redirect verarbeiten (automatisch aus dem Popup)",
          "description": "Wenn Microsoft Entra ID zu Ihrer Callback-URL umleitet, empfängt diese Seite die URL aus dem Popup und extrahiert Code und State. Wenn nichts erscheint, stellen Sie sicher, dass die Redirect-URI genau Ihrer App-Registrierung entspricht und der Popup-Flow nicht blockiert wurde.",
          "errorTitle": "Callback-Fehler",
          "okTitle": "Callback OK"
        },
        "tokens": {
          "title": "Code gegen Tokens tauschen",
          "description": "Senden Sie einen POST an den Token-Endpunkt mit grant_type=authorization_code, Ihrer client_id, dem erhaltenen Code, redirect_uri und code_verifier. Klicken Sie auf ‚Senden‘, um zu tauschen.",
          "requestTitle": "Token-Anfrage",
          "responseTitle": "Token-Antwort"
        },
        "decode": {
          "title": "Tokens dekodieren (JWT)",
          "description": "Access- und ID-Tokens sind JWTs. Klicken Sie auf ‚Dekodieren‘, um Header und Payload lesbar anzuzeigen."
        },
        "validate": {
          "title": "Tokens validieren (Signatur und Claims)",
          "description": "Diese Anleitung zeigt, wie Sie die erhaltenen ID- und Access-Tokens validieren: zuerst die Signaturprüfung (kid -> Metadata -> JWKS -> Verify), danach die üblichen Claim-Prüfungen (aud, iss, tid, nonce, scopes/roles, exp, nbf, iat)."
        },
        "callApi": {
          "title": "Geschützte API aufrufen",
          "description": "Rufen Sie einen geschützten Endpunkt mit dem Bearer Access Token auf. Einige APIs (z. B. Microsoft Graph) unterstützen Browser-CORS; andere erfordern in Produktion ggf. einen Server-Proxy. Klicken Sie auf ‚GET senden‘, um die Anfrage auszuführen und die Antwort zu prüfen."
        }
      },
      "labels": {
        "tenantId": "Entra Tenant ID",
        "clientId": "Client ID",
        "redirectUri": "Redirect URI",
        "scopes": "Scopes (mit Leerzeichen getrennt)",
        "authEndpoint": "Authorization Endpoint",
        "tokenEndpoint": "Token Endpoint",
        "pkceMethod": "Code-Challenge-Methode",
        "codeVerifier": "Code Verifier",
        "codeChallenge": "Code Challenge",
        "responseType": "response_type",
        "state": "state",
        "nonce": "nonce",
  "responseMode": "response_mode",
  "prompt": "prompt",
  "loginHint": "login_hint",
        "authUrlPreview": "Vorschau der Autorisierungs-URL",
        "callbackUrl": "Callback-URL",
    "callbackBody": "POST-Body",
  "error": "Fehler",
  "errorUri": "Fehler-URI",
  "errorDescription": "Fehlerbeschreibung",
        "extractedCode": "Extrahierter Code",
        "extractedState": "Extrahierter State",
        "tokenRequest": "Token-Anfrage (x-www-form-urlencoded)",
  "tokenEndpointPreview": "Token-Endpunkt",
        "responsePreview": "Antwortvorschau",
        "accessToken": "Access Token (JWT)",
        "idToken": "ID Token (JWT)",
        "accessHeader": "Access-Token-Header",
        "accessPayload": "Access-Token-Payload",
        "idHeader": "ID-Token-Header",
        "idPayload": "ID-Token-Payload",
        "apiEndpoint": "API-Endpunkt",
        "apiHeaders": "Request-Header",
        "apiResponse": "Antwortvorschau"
      },
      "placeholders": {
    "tenantId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
    "clientId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
    "scopes": "openid profile offline_access api://.../scope.read",
    "selectMethod": "Methode auswählen",
    "codeVerifier": "Zufälliger String mit hoher Entropie",
    "codeChallenge": "Abgeleitet aus code_verifier (S256/plain)",
    "state": "Optionaler State (empfohlen)",
    "nonce": "Optionale Nonce",
    "loginHint": "user@domain.com"
      },
      "buttons": {
        "generate": "Generieren",
        "openPopup": "Popup öffnen",
        "copyUrl": "URL kopieren",
        "sending": "Senden…",
        "send": "Senden",
        "copyRequest": "Anfrage kopieren",
        "decode": "Dekodieren",
        "sendGet": "GET senden",
        "previous": "Zurück",
        "next": "Weiter"
      },
      "options": {
        "responseMode": {
          "query": "query",
          "form_post": "form_post"
        },
        "prompt": {
          "login": "login",
          "consent": "consent",
          "select_account": "select_account",
          "none": "none"
        }
      },
      "notes": {
        "accessHeaderNonce": "Dieser Access-Token-Header enthält ein <code>nonce</code>-Feld. Dabei handelt es sich um einen anbieter­spezifischen JOSE-Header und er steht nicht im Zusammenhang mit dem OIDC-Claim <code>nonce</code>, der in der ID-Token-Payload validiert wird."
      },
      "validateUi": {
        "graphWarning": "Access Tokens für Microsoft Graph (aud <code>{aud}</code>) können in der Regel nicht von diesem Client signaturgeprüft werden. Nur Microsoft Graph kann deren Signaturen validieren.",
        "idTokenTitle": "ID-Token",
        "accessTokenTitle": "Access Token",
        "signatureValidation": "Signaturprüfung",
        "verified": "Verifiziert",
        "notVerified": "Nicht verifiziert",
        "skipped": "Übersprungen",
        "skippedAria": "übersprungen",
        "steps": {
          "extractKid": "kid aus Token-Header extrahieren:",
          "extractAlg": "alg aus Token-Header extrahieren:",
          "extractVersion": "Version aus Token-Payload extrahieren:",
          "extractIssuer": "Issuer (iss) aus Token-Payload extrahieren:",
          "buildMetadata": "Metadata-Endpunkt bilden:",
          "resolveJwks": "JWKS-URL ermitteln:",
          "fetchJwksFindKey": "JWKS abrufen und Schlüssel finden",
          "verifySignature": "Signatur mit alg prüfen"
        },
        "reason": "Grund:",
        "error": "Fehler:",
        "publicKeyPem": "Öffentlicher Schlüssel (PEM)",
        "copy": "Kopieren",
        "claimValidations": "Claim-Validierungen",
        "claims": {
          "id": {
            "aud": "aud (Audience) sollte Ihrer client_id entsprechen:",
            "iss": "iss (Issuer) sollte Ihrer Authority/Ihrem Tenant entsprechen:",
            "exp": "exp (Ablauf) liegt in der Zukunft:",
            "nbfIat": "nbf/iat (not before / issued at) plausibel:",
            "nonce": "nonce (Anti-Replay) sollte der Anfrage entsprechen:"
          },
          "access": {
            "aud": "aud (Audience) sollte API/Ressource entsprechen:",
            "iss": "iss (Issuer) sollte Ihrem Tenant-Issuer entsprechen:",
            "exp": "exp (Ablauf) liegt in der Zukunft:",
            "nbfIat": "nbf/iat (not before / issued at) plausibel:",
            "scp": "scp (Scopes) vorhanden:",
            "msGraph": "(MS Graph API)"
          }
        }
      },
      "help": {
        "tenantId": "Directory-(Tenant-)GUID Ihrer Entra ID Instanz.",
        "clientId": "Anwendungs-(Client-)ID Ihrer Public-Client-App-Registrierung.",
        "redirectUri": "Callback-URL für diese App. Muss in der App-Registrierung hinterlegt sein.",
        "scopes": "Durch Leerzeichen getrennte Scopes (z. B. openid profile offline_access api://.../scope.read).",
  "authEndpoint": "OAuth 2.0 v2 Autorisierungsendpunkt. Tenant wird in \u007Btenant\u007D eingesetzt.",
  "tokenEndpoint": "OAuth 2.0 v2 Tokenendpunkt. Tenant wird in \u007Btenant\u007D eingesetzt.",
        "codeVerifier": "Zufälliger String mit hoher Entropie, der vom Client geheim gehalten wird (PKCE).",
        "codeChallenge": "Base64url-kodierter SHA-256-Hash des code_verifier (S256).",
        "responseType": "OAuth-Parameter response_type; für PKCE ist es 'code'.",
        "state": "Undurchsichtiger Wert zur Sitzungszuordnung; hilft, CSRF zu verhindern.",
        "nonce": "String zur Verknüpfung einer Client-Sitzung mit einem ID Token; mindert Replay-Angriffe.",
  "responseMode": "Wohin die Antwort geliefert werden soll (query oder form_post).",
  "prompt": "Steuert das Verhalten: login, consent, select_account, create oder none.",
  "loginHint": "Benutzernamen/Anmeldehinweis vorbefüllen (z. B. E-Mail).",
        "authUrlPreview": "Die vollständige Autorisierungs-URL, die im Popup geöffnet wird.",
    "callbackUrl": "Die vollständige Callback-URL, die nach der Anmeldung aus dem Popup übernommen wird.",
    "callbackBody": "Wenn response_mode=form_post verwendet wird, sendet der Identity Provider die Parameter im POST-Body.",
  "error": "Kurzer Fehlercode, der vom Autorisierungsserver zurückgegeben wird (Parameter 'error').",
  "errorUri": "Optionale URI mit weiteren Informationen zum Fehler (Parameter 'error_uri').",
  "errorDescription": "Optionale, menschenlesbare Beschreibung des Fehlers (Parameter 'error_description').",
        "extractedCode": "Der Autorisierungscode, der aus der Callback-URL extrahiert wurde.",
        "extractedState": "Der State-Wert aus der Callback-URL (falls gesetzt).",
        "tokenRequest": "Der POST-Body zum Tauschen des Codes gegen Tokens.",
  "tokenEndpointPreview": "Die vollständige Token-Endpunkt-URL, die zum Tauschen des Autorisierungscodes verwendet wird.",
        "responsePreview": "Rohantwort des Tokenendpunkts (falls JSON, formatiert).",
        "accessToken": "Access Token zum Aufrufen von APIs. Wird als JWT-String angezeigt.",
        "idToken": "ID Token, das die Benutzeridentität darstellt. Wird als JWT-String angezeigt.",
        "accessHeader": "Dekodierter JWT-Header des Access Tokens.",
        "accessPayload": "Dekodierte JWT-Payload des Access Tokens.",
        "idHeader": "Dekodierter JWT-Header des ID Tokens.",
        "idPayload": "Dekodierte JWT-Payload des ID Tokens.",
        "apiEndpoint": "HTTP-Endpunkt, der mit dem Access Token aufgerufen wird (z. B. Microsoft Graph).",
        "apiHeaders": "HTTP-Header, die für den API-Aufruf verwendet werden (einschließlich Authorization).",
        "apiResponse": "Rohantwort des API-Aufrufs (falls JSON, formatiert)."
      ,
  "checkState": "Bitte prüfen Sie, ob der extrahierte State mit dem erwarteten State übereinstimmt.",
  "checkStateAlways": "Prüfen Sie unten, ob der extrahierte State mit dem erwarteten State übereinstimmt, bevor Sie fortfahren.",
        "stateValid": "State stimmt überein",
        "stateInvalid": "State stimmt nicht überein"
      },
      "errors": {
  "tenantIdInvalid": "Tenant ist erforderlich und muss eine GUID sein",
  "clientIdRequired": "Client ID ist erforderlich und muss eine GUID sein",
  "clientIdInvalid": "Client ID muss eine GUID sein",
        "redirectUriInvalid": "Redirect URI muss eine gültige http(s)-URL sein"
        ,
        "codeVerifierRequired": "Code Verifier ist erforderlich",
        "codeChallengeRequired": "Code Challenge ist erforderlich"
      }
    }
  },
  "Error": {
    "title": "Etwas ist schief gelaufen.",
    "description": "Ein unerwarteter Fehler ist aufgetreten. Sie können es erneut versuchen.",
    "tryAgain": "Erneut versuchen"
  }
}
