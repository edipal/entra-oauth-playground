{
  "HomePage": {
    "title": "Microsoft Entra OAuth Playground",
    "description": "Entdecken Sie OAuth 2.0- und OpenID-Connect-Flows von Anfang bis Ende mit einer geführten Schritt-für-Schritt-Erfahrung. Konfigurieren Sie Ihre Microsoft-Entra-App-Einstellungen, erzeugen Sie Autorisierungs-URLs und gehen Sie PKCE, Callback und Token-Austausch durch. Sehen Sie an jeder Stelle die exakten Requests und Responses, dekodieren und validieren Sie Tokens und verstehen Sie wichtige Claims sowie Sicherheitsprüfungen."
  },
  "Menu": {
    "Home": "Startseite",
    "GettingStarted": "Erste Schritte",
    "PublicClients": "Öffentliche Clients",
    "ConfidentialClients": "Vertrauliche Clients",
    "AuthorizationCodeFlow": "Authorization Code Flow",
    "ClientCredentialsFlow": "Client Credentials Flow"
  },
  "StepAuthorize": {
    "sections": {
      "authorize": {
        "description": "Wir erstellen die Autorisierungs-URL mit Ihrer client_id, redirect_uri, scopes, optionalem state und nonce sowie den PKCE-Parametern. Sie können response_mode, prompt und login_hint setzen, um zu steuern, wie der Identitätsanbieter Ergebnisse zurückliefert oder wie sich die Anmeldung verhält. Klicken Sie auf \"Popup öffnen\", um sich anzumelden und zuzustimmen. Nach Abschluss leitet das Popup zurück und Schritt 5 füllt den Code automatisch aus."
      },
      "settings": {
        "userProvidedTitle": "Vom Benutzer bereitgestellte Einstellungen",
        "userProvidedDescription": "Diese Felder werden von Ihnen konfiguriert und für die Autorisierungsanfrage verwendet."
      }
    },
    "labels": {
      "responseType": "response_type",
      "state": "state",
      "nonce": "nonce",
      "responseMode": "response_mode",
      "prompt": "prompt",
      "loginHint": "login_hint"
    },
    "placeholders": {
      "state": "Optionaler state (empfohlen)",
      "nonce": "Optionale nonce",
      "selectMethod": "Methode auswählen",
      "loginHint": "user@domain.com"
    },
    "buttons": {
      "generate": "Generieren",
      "openPopup": "Popup öffnen"
    },
    "options": {
      "responseMode": {
        "query": "query",
        "form_post": "form_post"
      },
      "prompt": {
        "login": "login",
        "consent": "consent",
        "select_account": "select_account",
        "none": "none"
      }
    },
    "help": {
      "responseType": "OAuth-Parameter response_type; für PKCE ist er 'code'.",
      "state": "Opaker Wert, um den Zustand zwischen Anfrage und Callback zu erhalten; hilft, CSRF zu verhindern.",
      "nonce": "Zeichenfolge, um eine Client-Sitzung mit einem ID-Token zu verknüpfen; hilft, Replay-Angriffe zu mindern.",
      "responseMode": "Wo die Antwort zurückgegeben werden soll (query oder form_post).",
      "prompt": "Steuert das Verhalten: login, consent, select_account oder none.",
      "loginHint": "Benutzernamen bzw. Sign-In-Hinweis vorausfüllen (z. B. E-Mail).",
      "authUrlPreview": "Die vollständige Autorisierungs-URL, die im Popup geöffnet wird."
    }
  },
  "StepCallApi": {
    "sections": {
      "callApi": {
        "description": "Rufen Sie eine geschützte API mit dem Access Token auf. Passen Sie den Endpunkt an und senden Sie die GET-Anfrage, um die Antwort zu sehen."
      }
    },
    "labels": {
      "apiEndpoint": "API-Endpunkt",
      "apiHeaders": "Anfrage-Header",
      "apiResponse": "Antwortvorschau"
    },
    "help": {
      "apiEndpoint": "HTTP-Endpunkt, der mit dem Access Token aufgerufen wird (z. B. Microsoft Graph).",
      "apiHeaders": "HTTP-Header für den API-Aufruf (enthält Authorization).",
      "apiResponse": "Rohe Antwort des API-Aufrufs (formatiert, falls JSON)."
    },
    "buttons": {
      "sendGet": "GET senden",
      "sending": "Senden..."
    }
  },
  "StepCallback": {
    "sections": {
      "callback": {
        "description": "Prüfen Sie die Callback-URL oder den POST-Body auf den Autorisierungscode, state oder zurückgegebene Fehler nach der Anmeldung.",
        "okTitle": "Callback OK",
        "errorTitle": "Callback-Fehler"
      }
    },
    "labels": {
      "callbackUrl": "Callback-URL",
      "callbackBody": "POST-Body",
      "extractedCode": "Extrahierter Code",
      "extractedState": "Extrahierter state",
      "error": "Fehler",
      "errorUri": "Fehler-URI",
      "errorDescription": "Fehlerbeschreibung"
    },
    "help": {
      "callbackUrl": "Die vollständige Callback-URL, die nach der Anmeldung aus dem Popup erfasst wurde.",
      "callbackBody": "Wenn response_mode=form_post, sendet der Identity Provider die Parameter im POST-Body.",
      "extractedCode": "Der Autorisierungscode, der aus den Callback-Parametern extrahiert wurde.",
      "extractedState": "Der state-Wert, der aus den Callback-Parametern extrahiert wurde (falls gesetzt).",
      "stateValid": "state stimmt überein",
      "stateInvalid": "state stimmt nicht überein",
      "error": "Kurzer Fehlercode vom Autorisierungsserver (Parameter 'error').",
      "errorUri": "Optionale URI mit weiteren Informationen zum Fehler (Parameter 'error_uri').",
      "errorDescription": "Optionale menschenlesbare Beschreibung des Fehlers (Parameter 'error_description')."
    }
  },
  "StepPkce": {
    "sections": {
      "pkce": {
        "description": "PKCE schützt öffentliche Clients. Klicken Sie auf die Schaltfläche \"Generieren\" (links vom Code-Verifier-Feld), um einen hochentropischen code_verifier und den code_challenge (standardmäßig S256) zu erzeugen."
      }
    },
    "labels": {
      "codeVerifier": "Code Verifier",
      "codeChallenge": "Code Challenge"
    },
    "placeholders": {
      "codeVerifier": "Zufälliger String mit hoher Entropie",
      "codeChallenge": "Abgeleitet aus code_verifier (S256/plain)"
    },
    "buttons": {
      "generate": "Generieren"
    },
    "errors": {
      "codeVerifierRequired": "Code Verifier ist erforderlich",
      "codeChallengeRequired": "Code Challenge ist erforderlich"
    },
    "help": {
      "codeVerifier": "Hochentropischer Zufallsstring, der vom Client geheim gehalten wird (PKCE).",
      "codeChallenge": "Base64url-codierter SHA-256-Hash des code_verifier (S256)."
    }
  },
  "StepTokens": {
    "sections": {
      "tokens": {
        "description": "Tauschen Sie den Autorisierungscode gegen Tokens und prüfen Sie Anfrage sowie Antwort.",
        "requestTitle": "Token-Anfrage",
        "responseTitle": "Token-Antwort"
      }
    },
    "labels": {
      "tokenEndpointPreview": "Token-Endpunkt",
      "tokenRequest": "Token-Anfrage",
      "responsePreview": "Antwortvorschau"
    },
    "buttons": {
      "send": "Senden",
      "sending": "Senden..."
    },
    "help": {
      "tokenEndpointPreview": "Die vollständige Token-Endpunkt-URL, die zum Eintausch des Autorisierungscodes verwendet wird.",
      "tokenRequest": "Der POST-Body (x-www-form-urlencoded), mit dem der Code gegen Tokens eingetauscht wird."
    }
  },
  "StepValidate": {
    "sections": {
      "validate": {
        "title": "Tokens validieren",
        "description": "Diese Anleitung zeigt, wie Sie die erhaltenen ID- und Access Tokens validieren: zuerst die Signaturprüfung (kid -> Metadaten -> jwks -> verify), dann die üblichen Claim-Prüfungen (aud, iss, tid, nonce, scopes/Rollen, exp, nbf, iat)."
      }
    },
    "validateUi": {
      "graphWarning": "Access Tokens für Microsoft Graph (aud <code>{aud}</code>) können von diesem Client typischerweise nicht signaturgeprüft werden. Nur Microsoft Graph kann deren Signaturen validieren.",
      "idTokenTitle": "ID-Token",
      "accessTokenTitle": "Access Token",
      "signatureValidation": "Signaturprüfung",
      "verified": "Verifiziert",
      "notVerified": "Nicht verifiziert",
      "skipped": "Übersprungen",
      "skippedAria": "übersprungen",
      "steps": {
        "extractKid": "kid aus Token-Header auslesen",
        "extractAlg": "alg aus Token-Header auslesen",
        "extractVersion": "Token-Version ermitteln",
        "extractIssuer": "Issuer (iss) auslesen",
        "buildMetadata": "Metadata-URL aus iss erzeugen",
        "resolveJwks": "JWKS-URI ermitteln",
        "fetchJwksFindKey": "JWKS abrufen und Schlüssel finden",
        "verifySignature": "Signatur mit alg prüfen"
      },
      "reason": "Grund:",
      "error": "Fehler:",
      "publicKeyPem": "Öffentlicher Schlüssel (PEM)",
      "copy": "Kopieren",
      "claimValidations": "Claim-Prüfungen",
      "claims": {
        "id": {
          "aud": "aud muss client_id entsprechen",
          "iss": "iss muss zum Mandanten passen",
          "exp": "exp muss in der Zukunft liegen",
          "nbfIat": "nbf/iat müssen <= jetzt sein (mit Puffer)",
          "nonce": "nonce muss übereinstimmen"
        },
        "access": {
          "aud": "aud vorhanden (API-Audience)",
          "iss": "iss muss zum Mandanten passen",
          "exp": "exp muss in der Zukunft liegen",
          "nbfIat": "nbf/iat müssen <= jetzt sein (mit Puffer)",
          "scp": "scp (delegierte Scopes)",
          "roles": "roles (App-Berechtigungen)",
          "wids": "wids (App-Rollen)",
          "ver": "ver (Token-Version)",
          "msGraph": "(Microsoft-Graph-Audience; nur Graph kann Signaturen verifizieren)"
        }
      }
    }
  },
  "StepSettings": {
    "sections": {
      "settings": {
        "description": "Konfigurieren Sie Ihre Client-Einstellungen für den Authorization-Code-Flow.",
        "userProvidedTitle": "Vom Benutzer bereitgestellte Einstellungen",
        "userProvidedDescription": "Diese Felder werden von Ihnen konfiguriert und für den Autorisierungsantrag verwendet.",
        "localStorageNotice": "Diese Werte werden zur Vereinfachung im lokalen Speicher Ihres Browsers gespeichert.",
        "resolvedTitle": "Abgeleitete (schreibgeschützte) Werte",
        "resolvedDescription": "Diese Werte werden aus dem Mandanten und anderen Eingaben abgeleitet. Sie dienen nur zur Anzeige und können hier nicht geändert werden."
      }
    },
    "labels": {
      "tenantId": "Entra-Mandanten-ID",
      "clientId": "Client-ID",
      "scopes": "Berechtigungen (leerzeichengetrennt)",
      "authEndpoint": "Autorisierungsendpunkt",
      "tokenEndpoint": "Token-Endpunkt",
      "redirectUri": "Umleitungs-URI",
      "streamlined": "Streamlined-Modus",
      "pkceEnabled": "PKCE verwenden"
    },
    "placeholders": {
      "tenantId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
      "clientId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
      "scopes": "openid profile offline_access api://.../scope.read"
    },
    "toggles": {
      "streamlinedOn": "Aktiviert",
      "streamlinedOff": "Deaktiviert",
      "pkceEnabledOn": "Aktiviert",
      "pkceEnabledOff": "Deaktiviert"
    },
    "help": {
      "tenantId": "Verzeichnis-(Mandanten-)GUID Ihrer Entra ID.",
      "clientId": "Anwendungs-(Client-)ID Ihrer App-Registrierung.",
      "scopes": "Durch Leerzeichen getrennte Berechtigungen (z. B. openid profile offline_access api://.../scope.read).",
      "authEndpoint": "OAuth 2.0 v2 Autorisierungsendpunkt. Der Mandant wird in {tenant} eingesetzt.",
      "tokenEndpoint": "OAuth 2.0 v2 Token-Endpunkt. Der Mandant wird in {tenant} eingesetzt.",
      "redirectUri": "Callback-URL dieser App. Muss in der App-Registrierung hinterlegt sein.",
      "streamlined": "Führt Schritte automatisch aus und blendet erweiterte Felder aus, um die Demo zu beschleunigen.",
      "pkceEnabled": "PKCE ist für öffentliche Clients empfohlen und für vertrauliche optional."
    },
    "errors": {
      "tenantIdInvalid": "Mandant ist erforderlich und muss eine GUID sein",
      "clientIdRequired": "Client-ID ist erforderlich und muss eine GUID sein",
      "clientIdInvalid": "Client-ID muss eine GUID sein",
      "redirectUriInvalid": "Umleitungs-URI muss eine gültige http(s)-URL sein"
    }
  },
  "StepDecode": {
    "sections": {
      "decode": {
        "description": "Access- und ID-Tokens sind JWTs. Klicken Sie auf \"Dekodieren\", um Header und Payload in lesbarer Form zu sehen."
      }
    },
    "labels": {
      "accessToken": "Access Token (JWT)",
      "idToken": "ID-Token (JWT)",
      "accessHeader": "Access-Token-Header",
      "accessPayload": "Access-Token-Payload",
      "idHeader": "ID-Token-Header",
      "idPayload": "ID-Token-Payload"
    },
    "help": {
      "accessToken": "Access Token zum Aufrufen von APIs. Wird als JWT-String angezeigt.",
      "idToken": "ID-Token, das die Benutzeridentität repräsentiert. Wird als JWT-String angezeigt.",
      "accessHeader": "Dekodierter JWT-Header des Access Tokens.",
      "accessPayload": "Dekodierte JWT-Payload des Access Tokens.",
      "idHeader": "Dekodierter JWT-Header des ID-Tokens.",
      "idPayload": "Dekodierte JWT-Payload des ID-Tokens."
    },
    "buttons": {
      "decode": "Dekodieren"
    },
    "notes": {
      "accessHeaderNonce": "Dieser Access-Token-Header enthält ein <code>nonce</code>-Feld. Das ist ein anbieter­spezifischer JOSE-Header und nicht mit dem OIDC-<code>nonce</code>-Claim verwandt, der im ID-Token-Payload validiert wird."
    }
  },
  "StepOverview": {
    "sections": {
      "settings": {
        "flowIntro": "Überblick über den Authorization-Code-Flow mit PKCE.",
        "flowDiagram": "Client (Browser)\n   |\n   | 1) code_verifier + code_challenge (S256) erzeugen\n   v\nAuthorize Endpoint ------------------------------>\n   |   GET .../authorize?client_id=...&redirect_uri=...\n   |        &response_type=code&scope=...&state=...\n   |        &code_challenge=...&code_challenge_method=S256\n   |\n   | 2) Benutzer meldet sich an und gibt Zustimmung\n   v\nRedirect (Callback) <------------------------------\n   |   http(s)://your-app/callback/auth-code?code=...&state=...\n   |\n   | 3) Code mit code_verifier gegen Tokens eintauschen\n   v\nToken Endpoint ----------------------------------->\n   |   POST grant_type=authorization_code\n   |        &client_id=...\n   |        &code=...\n   |        &redirect_uri=...\n   |        &code_verifier=...\n   |\n   | 4) Tokens erhalten (access_token, id_token, ...)\n   v\nGeschützte API (z. B. Graph) -------------------->\n   |   Authorization: Bearer <access_token>\n   v\n  Response"
      }
    }
  },
  "StepAuthentication": {
    "description": "Wählen Sie, wie sich der Client beim Token-Endpunkt authentifiziert, wenn der Autorisierungscode eingetauscht wird.",
    "methodOptions": {
      "secret": "Client-Geheimnis",
      "certificate": "Zertifikat (private_key_jwt)"
    },
    "labels": {
      "clientAuthMethod": "Client-Authentifizierung",
      "clientSecret": "Client-Geheimnis",
      "privateKeyPem": "Privater Schlüssel (PKCS#8 PEM)",
      "publicKeyPem": "Öffentlicher Schlüssel (SPKI PEM)",
      "certificatePem": "Zertifikat (PEM)",
      "thumbprintSha1": "Thumbprint (SHA-1)",
      "clientAssertionKid": "Key ID (kid)",
      "assertionClaims": "JWT-Ansprüche (Vorschau)",
      "testAssertion": "Signiertes JWT",
      "decodedAssertion": "Dekodiertes JWT"
    },
    "help": {
      "clientAuthMethod": "Wählen Sie, wie sich der Client beim Token-Endpunkt beim Code-Tausch authentifiziert.",
      "clientSecret": "Ihr vertrauliches Client-Geheimnis. Zu Demo-Zwecken bleibt dieser Wert nur im Speicher (nicht persistent).",
      "privateKeyPem": "Bewahren Sie ihn sicher auf! Dieser private Schlüssel wird zum Signieren des client_assertion JWT verwendet.",
      "publicKeyPem": "Der öffentliche Schlüssel, der zu Ihrem privaten Schlüssel gehört.",
      "certificatePem": "Laden Sie dieses Zertifikat in Entra ID unter App-Registrierungen → Zertifikate und Geheimnisse hoch.",
      "thumbprintSha1": "Verwenden Sie dies als Key ID (kid). Dies entspricht dem Wert im Entra ID-Portal.",
      "clientAssertionKid": "Sollte dem \"Thumbprint\" in Entra ID → App-Registrierung → Zertifikate und Geheimnisse entsprechen.",
      "assertionClaims": "Vorschau der JWT-Ansprüche, die im Parameter client_assertion verwendet werden.",
      "testAssertion": "Ein Test-client_assertion JWT, das mit Ihrem privaten Schlüssel generiert wurde.",
      "decodedAssertion": "Der dekodierte Header und Payload des Test-JWT zur Überprüfung."
    },
    "placeholders": {
      "clientAuthMethod": "Methode auswählen",
      "clientSecret": "Client-Geheimnis eingeben",
      "privateKeyPem": "Klicken Sie auf \"Schlüsselpaar generieren\", um einen privaten Schlüssel zu erstellen",
      "publicKeyPem": "Wird automatisch mit dem privaten Schlüssel erzeugt",
      "certificatePem": "Klicken Sie auf \"Zertifikat generieren\", um ein selbstsigniertes Zertifikat zu erstellen",
      "thumbprintSha1": "Wird automatisch mit dem Zertifikat erzeugt",
      "clientAssertionKid": "Wird automatisch ausgefüllt, wenn das Zertifikat erzeugt wird",
      "assertionClaims": "Klicken Sie auf \"Ansprüche anzeigen\", um die JWT-Ansprüche zu sehen",
      "testAssertion": "Klicken Sie auf \"Test-Assertion erzeugen\", um ein Test-JWT zu erstellen",
      "decodedAssertion": "Wird automatisch erzeugt, wenn die Test-Assertion erstellt wird"
    },
    "steps": {
      "generateKeyPair": {
        "title": "Schritt 1: RSA-Schlüsselpaar generieren",
        "description": "Generieren Sie ein 2048-Bit-RSA-Schlüsselpaar zum Signieren des client_assertion JWT."
      },
      "generateCertificate": {
        "title": "Schritt 2: Selbstsigniertes Zertifikat erstellen",
        "description": "Erstellen Sie ein selbstsigniertes X.509-Zertifikat für den Upload nach Microsoft Entra ID. Der Thumbprint kann als kid verwendet werden."
      },
      "configureKid": {
        "title": "Schritt 3: Key ID (kid) - automatisch ausgefüllt",
        "description": "Der Zertifikat-Thumbprint (SHA-1) wird automatisch als Key ID verwendet und entspricht dem Wert im Entra ID-Portal."
      },
      "previewClaims": {
        "title": "Schritt 4: Client-Assertion-Ansprüche anzeigen",
        "description": "Sehen Sie die JWT-Ansprüche, die im Parameter client_assertion verwendet werden."
      },
      "testAssertion": {
        "title": "Schritt 5: Signierte Assertion testen",
        "description": "Erzeugen Sie ein client_assertion JWT zum Testen. Die eigentliche Assertion wird beim Aufruf des Token-Endpunkts erstellt."
      }
    },
    "buttons": {
      "generateKeyPair": "Schlüsselpaar generieren",
      "generateCertificate": "Zertifikat generieren",
      "confirmKid": "Key-ID bestätigen",
      "previewClaims": "Ansprüche anzeigen",
      "generateTestAssertion": "Test-Assertion erzeugen"
    },
    "aria": {
      "keyPairGenerated": "Schlüsselpaar erzeugt",
      "certificateGenerated": "Zertifikat erzeugt",
      "kidConfigured": "kid konfiguriert",
      "claimsPreviewed": "Ansprüche angezeigt",
      "testAssertionGenerated": "Test-Assertion erzeugt"
    },
    "decoded": {
      "headerLabel": "Header:",
      "payloadLabel": "Payload:"
    },
    "note": {
      "label": "Hinweis:",
      "body": "Aufgrund von Browser-Einschränkungen müssen Secrets an den Server gesendet werden, wo der Aufruf des Token-Endpunkts tatsächlich erfolgt."
    },
    "errors": {
      "generateKeyPair": "Fehler beim Erzeugen des Schlüsselpaares: {error}",
      "keyPairRequired": "Bitte erzeugen Sie zuerst ein Schlüsselpaar.",
      "generateCertificate": "Fehler beim Erzeugen des Zertifikats: {error}",
      "missingKid": "Bitte geben Sie zuerst eine Key-ID ein oder erzeugen Sie sie.",
      "missingClientConfig": "Bitte konfigurieren Sie zuerst Client-ID und Token-Endpunkt.",
      "missingKeyOrConfig": "Bitte erzeugen Sie zuerst ein Schlüsselpaar und konfigurieren Sie die Einstellungen.",
      "generateAssertion": "Fehler beim Erzeugen der Assertion: {error}"
    }
  },
  "AuthorizationCode": {
    "PublicClient": {
      "Main": {
        "title": "Authorization Code (Öffentlicher Client)",
        "header": {
          "resetAria": "Zurücksetzen",
          "resetTitle": "Zurücksetzen (Einstellungen behalten)",
          "eraseAria": "Einstellungen löschen",
          "eraseTitle": "Einstellungen löschen und zurücksetzen"
        },
        "steps": {
          "overview": "Übersicht",
          "settings": "Einstellungen",
          "pkce": "PKCE",
          "authorize": "Autorisieren",
          "callback": "Callback",
          "tokens": "Tokens",
          "decode": "Dekodieren",
          "validate": "Validieren",
          "callApi": "API aufrufen"
        },
        "buttons": {
          "previous": "Zurück",
          "next": "Weiter"
        },
        "overview": {
          "flowIntro": "Überblick über den Authorization-Code-Flow mit PKCE für öffentliche Clients (ohne Client-Geheimnis).",
          "flowDiagram": "Client (SPA)\n   |\n   | 1) code_verifier + code_challenge (S256) erzeugen\n   v\nAuthorize Endpoint ------------------------------>\n   |   GET .../authorize?client_id=...&redirect_uri=...\n   |        &response_type=code&scope=...&state=...\n   |        &code_challenge=...&code_challenge_method=S256\n   |\n   | 2) Benutzer meldet sich an und gibt Zustimmung\n   v\nRedirect (Callback) <------------------------------\n   |   https://app/callback?code=...&state=...\n   |\n   | 3) Code gegen Tokens eintauschen (ohne Geheimnis)\n   v\nToken Endpoint ----------------------------------->\n   |   POST grant_type=authorization_code\n   |        &client_id=...\n   |        &code=...\n   |        &redirect_uri=...\n   |        &code_verifier=...\n   |\n   | 4) Tokens erhalten (access_token, id_token, ...)\n   v\nGeschützte API (z. B. Graph) -------------------->\n   |   Authorization: Bearer &lt;access_token&gt;\n   v\n  Response"
        }
      }
    },
    "ConfidentialClient": {
      "Main": {
        "title": "Authorization Code (Vertraulicher Client)",
        "header": {
          "resetAria": "Zurücksetzen",
          "resetTitle": "Zurücksetzen (Einstellungen behalten)",
          "eraseAria": "Einstellungen löschen",
          "eraseTitle": "Einstellungen löschen und zurücksetzen"
        },
        "steps": {
          "overview": "Übersicht",
          "settings": "Einstellungen",
          "pkce": "PKCE",
          "authorize": "Autorisieren",
          "callback": "Callback",
          "authentication": "Authentifizierung",
          "tokens": "Tokens",
          "decode": "Dekodieren",
          "validate": "Validieren",
          "callApi": "API aufrufen"
        },
        "buttons": {
          "previous": "Zurück",
          "next": "Weiter"
        },
        "overview": {
          "flowIntro": "Überblick über den Authorization-Code-Flow für vertrauliche Clients (mit Client-Authentifizierung).",
          "flowDiagram": "Client (Web/App)\n   |\n   | 1) (Optional) code_verifier + code_challenge (PKCE) erzeugen\n   v\nAuthorize Endpoint ------------------------------>\n   |   GET .../authorize?client_id=...&redirect_uri=...\n   |        &response_type=code&scope=...&state=...\n   |        &code_challenge=...&code_challenge_method=S256\n   |\n   | 2) Benutzer meldet sich an und gibt Zustimmung\n   v\nRedirect (Callback) <------------------------------\n   |   https://app/callback?code=...&state=...\n   |\n   | 3) Code gegen Tokens eintauschen mit Client-Auth\n   v\nToken Endpoint ----------------------------------->\n   |   POST grant_type=authorization_code\n   |        &client_id=...\n   |        &code=...\n   |        &redirect_uri=...\n   |        &client_secret=... ODER client_assertion=...\n   |        &code_verifier=... (falls PKCE)\n   |\n   | 4) Tokens erhalten (access_token, id_token, ...)\n   v\nGeschützte API (z. B. Graph) -------------------->\n   |   Authorization: Bearer &lt;access_token&gt;\n   v\n  Response"
        },
        "help": {
          "authEndpoint": "OAuth 2.0 v2 Autorisierungsendpunkt. Der Mandant wird in {tenant} eingesetzt.",
          "tokenEndpoint": "OAuth 2.0 v2 Token-Endpunkt. Der Mandant wird in {tenant} eingesetzt."
        },
        "pkce": {
          "disabled": {
            "title": "PKCE",
            "description": "PKCE ist für diesen Flow deaktiviert. Sie können es in den Einstellungen aktivieren."
          }
        }
      }
    }
  }
  ,
  "ClientCredentials": {
    "Main": {
      "title": "Client Credentials",
      "header": {
        "resetAria": "Zurücksetzen",
        "resetTitle": "Zurücksetzen (Einstellungen behalten)",
        "eraseAria": "Einstellungen löschen",
        "eraseTitle": "Einstellungen löschen und zurücksetzen"
      },
      "steps": {
        "overview": "Übersicht",
        "settings": "Einstellungen",
        "authentication": "Authentifizierung",
        "tokens": "Tokens",
        "decode": "Dekodieren",
        "validate": "Validieren",
        "callApi": "API aufrufen"
      },
      "buttons": {
        "previous": "Zurück",
        "next": "Weiter"
      },
      "overview": {
        "flowIntro": "Überblick über den Client-Credentials-Flow (App-Only, ohne Benutzer).",
        "flowDiagram": "Client (Daemon/App)\n   |\n   | 1) Client-Authentifizierung konfigurieren (Secret oder Zertifikat)\n   v\nToken-Endpunkt ----------------------------------->\n   |   POST grant_type=client_credentials\n   |        &client_id=...\n   |        &scope=...\n   |        &client_secret=... ODER client_assertion=...\n   |\n   | 2) access_token (App-Only) erhalten\n   v\nGeschützte API (z. B. Graph) --------------------->\n   |   Authorization: Bearer &lt;access_token&gt;\n   v\n  Response"
      }
    }
  }
}
